---
title: "Code to generate inputs tables and figures - ML methods"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
cat("\014") 
knitr::opts_chunk$set(echo = TRUE)
```

# Set script name

```{r}
file_name <- "Tables_3_to_5"
```

# Load packages

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyr)
library(dplyr)
library(caret)
library(randomForest)
library(glmnet)
library(xgboost)
library(parallel)
library(doParallel)
```

# Load transformed lagged characteristics

```{r}
load("../data_sets/scaled_annual_data_JFE.Rdata")
```

# Load masked fund returns

```{r}
load("../data_sets/masked_fund_returns.Rdata")
```


# Functions

```{r}
weights.in.top.funds <- function(data,thres){
  if(quantile(data,thres)<0){
    rescaled_data <- scales::rescale(data,to=c(0,1))
    ind <- (rescaled_data>quantile(rescaled_data,thres))
    weights <- (rescaled_data*ind)/sum(rescaled_data*ind)
  }else{
    ind <- (data>quantile(data,thres))
    weights <- (data*ind)/sum(data*ind)
  }
  return(weights)
}

computePortfolioReturns <- function(w,fund.returns){
  portf_ret <- array(NA,c(12,1))
  w_matrix <- c()
  for(r in 1:12){
    portf_ret[r]  <-  sum(w*fund.returns[,r],na.rm = TRUE)
    if(r<12){
      w <- w*(1+fund.returns[,r+1]) %>% 
        ifelse(is.na(.),0,.) 
      w <- w/sum(w)
      w_matrix <- cbind(w_matrix,w)
    }
  }
  return(list(portf_ret=portf_ret,w_matrix=w_matrix))
}

```


# Fund characteristics

```{r}
vars <- c("alpha6_1mo_12m","alpha6_1mo_12m_lag_1","alpha6_tstat_lag_1","mtna_lag_1","exp_ratio_lag_1","age_lag_1","flow_12m_lag_1","mgr_tenure_lag_1","turn_ratio_lag_1","flow_vol_12m_lag_1","value_added_12m_lag_1","beta_market_tstat_lag_1","beta_profit_tstat_lag_1","beta_invest_tstat_lag_1","beta_size_tstat_lag_1","beta_value_tstat_lag_1","beta_mom_tstat_lag_1","R2_lag_1")  

scaled_annual_data <- scaled_annual_data_JFE %>% 
  select(fundno,Date,all_of(vars))
```


# Out-of-sample experiment


```{r,warning=FALSE,message=FALSE}
# start cluster
cluster <- makeCluster(6) 
registerDoParallel(cluster)

# initialize variables
date.vector <- sort(unique(scaled_annual_data$Date))
total_size <- length(date.vector)
panel_length <- 10 # in years
thresholds <- c(0.80,0.90,0.95,0.99) 

# list of models (must be implemented according to that sequence)
models <- c("ols",
            "enet",
            "xgb",
            "rf")

# names of all strategies
strategies_prediction_weighted <- paste(rep(paste0(models,"_top"), each = length((1-thresholds)*100)), (1-thresholds)*100, sep = "_")
strategies_equally_weighted <- paste(rep(paste0(models,"_EW_top"), each = length((1-thresholds)*100)), (1-thresholds)*100, sep = "_")

# caret trainControl
fitControl <- trainControl(method = "cv",
                           number = 5,
                           allowParallel = TRUE)

# initialize matrices for storing portfolio returns
this_portf_ret <- c()
portf_ret_matrix <- c()
this_portf_ret_EW <- c()
portf_ret_matrix_Ew <- c()

# initialize vector for portfolio dates
portf_dates <- c()

# initialize variables for turnover computation
w.big <- w.big.EW <- array(0,c(n_distinct(scaled_annual_data$fundno),(total_size-panel_length),length(strategies_prediction_weighted))) 
rownames(w.big) <- rownames(w.big.EW) <- sort((unique(scaled_annual_data$fundno)))
turnover <- turnover.EW <- array(0,c((total_size-panel_length),length(strategies_prediction_weighted)))

# Start recursion
for(t in 1:(total_size-panel_length)){
  
  print(paste("Iteration",t,"out of",total_size-panel_length))
  
  index <- 1
  
  #-----------------------------------
  #         DATA
  #------------------------------------
  
  # train data
  train_data <- scaled_annual_data %>% 
    filter(Date %in% date.vector[(1):(t+panel_length-1)]) %>% # expanding window
    dplyr::select(-Date,-fundno) 
  
  # test data
  test_data <- scaled_annual_data %>% 
    filter(Date %in% date.vector[t+panel_length]) %>% 
    dplyr::select(-Date,-fundno)
  
  # funds in this iteration
  fund_codes <- scaled_annual_data %>% 
    filter(Date %in% date.vector[t+panel_length]) %>% 
    dplyr::select(fundno) %>% 
    as.matrix() %>% 
    as.character()
  
  # fund returns of this iteration
  initial.portf.date <- paste0(substr(date.vector[t+panel_length],1,4),"01")
  final.portf.date <-date.vector[t+panel_length]
  fund.returns <- masked_fund_returns %>%
    ungroup() %>% 
    dplyr::select(Date,fundno,mret) %>%
    filter(Date>=initial.portf.date,Date<=final.portf.date,fundno %in% fund_codes) %>% 
    spread(.,fundno,mret) %>%
    dplyr::select(-Date) %>%
    t() %>%
    as.matrix()
  
  
  #-----------------------------------
  #         START MODELLING
  #------------------------------------
  
  #-----------------------------------
  # OLS 
  #-----------------------------------
  set.seed(1011)
  ols.fit <- train_data %>%
    train(alpha6_1mo_12m ~ ., data = .,
          method = "lm",
          trControl = fitControl)
  y_hat  <- predict.train(ols.fit,newdata = test_data)
  for(thres in thresholds){
    #---------------------------
    # return-weighted portfolios
    #---------------------------
    # update weights
    w <- weights.in.top.funds(y_hat,thres)
    portf_ret <- computePortfolioReturns(w,fund.returns)$portf_ret
    this_portf_ret <- cbind(this_portf_ret,portf_ret)
    # compute turnover
    if(t>1){
      w.big[fund_codes,t,index] <- w
      turnover[t,index] <- sum(abs(w.big[,t,index]-w.big[,t-1,index]))
    }
    #---------------------------
    #equally-weighted portfolios
    #---------------------------
    # update weights
    w.ew <- w
    w.ew[w>0] <- 1/length(w.ew[w>0])
    portf_ret <- computePortfolioReturns(w.ew,fund.returns)$portf_ret
    this_portf_ret_EW <- cbind(this_portf_ret_EW,portf_ret)
    # compute turnover
    if(t>1){
      w.big.EW[fund_codes,t,index] <- w
      turnover.EW[t,index] <- sum(abs(w.big.EW[,t,index]-w.big.EW[,t-1,index]))
    }
    index <- index + 1
  }
  rm(ols.fit)
  gc()
  
  #-----------------------------------
  # Elastic net 
  #-----------------------------------
  set.seed(1011)
  enet.fit  <- train_data %>%
    train(alpha6_1mo_12m ~ ., data = .,
          method = "glmnet",
          trControl = fitControl,
          metric = "RMSE") 
  y_hat <- predict.train(enet.fit,newdata = test_data)
  for(thres in thresholds){
    #---------------------------
    # return-weighted portfolios
    #---------------------------
    # update weights
    w <- weights.in.top.funds(y_hat,thres)
    portf_ret <- computePortfolioReturns(w,fund.returns)$portf_ret
    this_portf_ret <- cbind(this_portf_ret,portf_ret)
    # compute turnover
    if(t>1){
      w.big[fund_codes,t,index] <- w
      turnover[t,index] <- sum(abs(w.big[,t,index]-w.big[,t-1,index]))
    }
    #---------------------------
    #equally-weighted portfolios
    #---------------------------
    # update weights
    w.ew <- w
    w.ew[w>0] <- 1/length(w.ew[w>0])
    portf_ret <- computePortfolioReturns(w.ew,fund.returns)$portf_ret
    this_portf_ret_EW <- cbind(this_portf_ret_EW,portf_ret)
    # compute turnover
    if(t>1){
      w.big.EW[fund_codes,t,index] <- w
      turnover.EW[t,index] <- sum(abs(w.big.EW[,t,index]-w.big.EW[,t-1,index]))
    }
    index <- index + 1
  }
  rm(enet.fit)
  gc()
  
  #-----------------------------------
  # gradient boosting 
  #-----------------------------------
  set.seed(1011)
  xgb.fit  <- train_data %>%
    train(alpha6_1mo_12m ~ ., data = .,
          method = "xgbTree",
          trControl = fitControl,
          metric = "RMSE",
          objective = "reg:squarederror")
  y_hat <- predict.train(xgb.fit,newdata = test_data)
  for(thres in thresholds){
    #---------------------------
    # return-weighted portfolios
    #---------------------------
    # update weights
    w <- weights.in.top.funds(y_hat,thres)
    portf_ret <- computePortfolioReturns(w,fund.returns)$portf_ret
    this_portf_ret <- cbind(this_portf_ret,portf_ret)
    # compute turnover
    if(t>1){
      w.big[fund_codes,t,index] <- w
      turnover[t,index] <- sum(abs(w.big[,t,index]-w.big[,t-1,index]))
    }
    #---------------------------
    #equally-weighted portfolios
    #---------------------------
    # update weights
    w.ew <- w
    w.ew[w>0] <- 1/length(w.ew[w>0])
    portf_ret <- computePortfolioReturns(w.ew,fund.returns)$portf_ret
    this_portf_ret_EW <- cbind(this_portf_ret_EW,portf_ret)
    # compute turnover
    if(t>1){
      w.big.EW[fund_codes,t,index] <- w
      turnover.EW[t,index] <- sum(abs(w.big.EW[,t,index]-w.big.EW[,t-1,index]))
    }
    index <- index + 1
  }
  rm(xgb.fit)
  gc()
  
  #-----------------------------------
  # random forest (with all predictors)
  #-----------------------------------
  set.seed(1011)
  rf.fit  <- train_data %>%
    train(alpha6_1mo_12m ~ ., data = .,
          method = "rf",
          ntree=1000,
          trControl = fitControl,
          metric = "RMSE") 
  y_hat <- predict.train(rf.fit,newdata = test_data)
  for(thres in thresholds){
    #---------------------------
    # return-weighted portfolios
    #---------------------------
    # update weights
    w <- weights.in.top.funds(y_hat,thres)
    portf_ret <- computePortfolioReturns(w,fund.returns)$portf_ret
    this_portf_ret <- cbind(this_portf_ret,portf_ret)
    # compute turnover
    if(t>1){
      w.big[fund_codes,t,index] <- w
      turnover[t,index] <- sum(abs(w.big[,t,index]-w.big[,t-1,index]))
    }
    #---------------------------
    #equally-weighted portfolios
    #---------------------------
    # update weights
    w.ew <- w
    w.ew[w>0] <- 1/length(w.ew[w>0])
    portf_ret <- computePortfolioReturns(w.ew,fund.returns)$portf_ret
    this_portf_ret_EW <- cbind(this_portf_ret_EW,portf_ret)
    # compute turnover
    if(t>1){
      w.big.EW[fund_codes,t,index] <- w
      turnover.EW[t,index] <- sum(abs(w.big.EW[,t,index]-w.big.EW[,t-1,index]))
    }
    index <- index + 1
  }
  rm(rf.fit)
  gc()
  
  #-----------------------------------
  # Stack and reset 
  #-----------------------------------
  portf_ret_matrix <- rbind(portf_ret_matrix,this_portf_ret)
  portf_ret_matrix_Ew <- rbind(portf_ret_matrix_Ew,this_portf_ret_EW)
  
  this_portf_ret <- this_portf_ret_EW <- this_portf_ret_IS <- this_portf_ret_EW_IS <- c()
  
  #-----------------------------------
  # Portfolio dates
  #-----------------------------------
  mons <- c("01","02","03","04","05","06","07","08","09","10","11","12")
  Dates <- as.matrix(paste0(substr(date.vector[t+panel_length],1,4),mons))
  portf_dates <- rbind(portf_dates,Dates)
  
  gc()
  
}

stopCluster(cluster)
```


# data frame contaning portfolio returns and dates

```{r}
# portfolio returns
colnames(portf_ret_matrix) <- strategies_prediction_weighted
colnames(portf_ret_matrix_Ew) <- strategies_equally_weighted

df.returns <- cbind.data.frame(portf_dates,portf_ret_matrix,portf_ret_matrix_Ew)
df.returns$portf_dates <- as.Date(paste0(as.character(df.returns$portf_dates), '01'), format='%Y%m%d')
df.returns$portf_dates <- format(df.returns$portf_dates,format="%Y%m")

# Save portfolio returns data frame
save(df.returns,file=paste0("../data_sets/Portfolio_returns_",file_name,".Rdata"))
```


# Save data frame of turnover

```{r}
colnames(turnover) <- strategies_prediction_weighted
colnames(turnover.EW) <- strategies_equally_weighted

save(turnover,turnover.EW,file=paste0("../data_sets/Turnovers_",file_name,".Rdata"))

```

